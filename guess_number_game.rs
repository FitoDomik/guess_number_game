use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("üéØ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∏–≥—Ä—É '–£–≥–∞–¥–∞–π —á–∏—Å–ª–æ'!");
    println!("üé≤ –Ø –∑–∞–≥–∞–¥–∞–ª —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 100. –ü–æ–ø—Ä–æ–±—É–π —É–≥–∞–¥–∞—Ç—å!");
    println!("üí° –í–≤–µ–¥–∏ 'quit' –∏–ª–∏ '–≤—ã—Ö–æ–¥', —á—Ç–æ–±—ã –≤—ã–π—Ç–∏ –∏–∑ –∏–≥—Ä—ã\n");

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ª—É—á–∞–π–Ω–æ–µ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 100
    let secret_number = rand::thread_rng().gen_range(1..=100);
    let mut attempts = 0;

    loop {
        println!("üî¢ –í–≤–µ–¥–∏ —Å–≤–æ—é –¥–æ–≥–∞–¥–∫—É:");

        let mut guess = String::new();

        // –ß–∏—Ç–∞–µ–º –≤–≤–æ–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        io::stdin()
            .read_line(&mut guess)
            .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Å—Ç—Ä–æ–∫—É");

        // –£–±–∏—Ä–∞–µ–º –ø—Ä–æ–±–µ–ª—ã –∏ –ø–µ—Ä–µ–≤–æ–¥—ã —Å—Ç—Ä–æ–∫
        let guess = guess.trim();

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Ö–æ—á–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—ã–π—Ç–∏
        if guess.eq_ignore_ascii_case("quit") || guess.eq_ignore_ascii_case("–≤—ã—Ö–æ–¥") {
            println!("üëã –î–æ —Å–≤–∏–¥–∞–Ω–∏—è! –ë—ã–ª–æ –ø—Ä–∏—è—Ç–Ω–æ –∏–≥—Ä–∞—Ç—å!");
            break;
        }

        // –ü—ã—Ç–∞–µ–º—Å—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å —Å—Ç—Ä–æ–∫—É –≤ —á–∏—Å–ª–æ
        let guess: u32 = match guess.parse() {
            Ok(num) => {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω
                if num < 1 || num > 100 {
                    println!("‚ö†Ô∏è  –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 100!");
                    continue;
                }
                num
            }
            Err(_) => {
                println!("‚ùå –≠—Ç–æ –Ω–µ —á–∏—Å–ª–æ! –ü–æ–ø—Ä–æ–±—É–π –µ—â–µ —Ä–∞–∑.");
                continue;
            }
        };

        attempts += 1;
        println!("üéØ –¢—ã —É–≥–∞–¥–∞–ª: {}", guess);

        // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å –∑–∞–≥–∞–¥–∞–Ω–Ω—ã–º —á–∏—Å–ª–æ–º
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("üìà –°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ! –ü–æ–ø—Ä–æ–±—É–π –±–æ–ª—å—à–µ."),
            Ordering::Greater => println!("üìâ –°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ! –ü–æ–ø—Ä–æ–±—É–π –º–µ–Ω—å—à–µ."),
            Ordering::Equal => {
                println!("üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –¢—ã —É–≥–∞–¥–∞–ª —á–∏—Å–ª–æ {} –∑–∞ {} –ø–æ–ø—ã—Ç–æ–∫!", 
                         secret_number, attempts);
                
                // –û—Ü–µ–Ω–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
                match attempts {
                    1 => println!("üèÜ –ù–µ–≤–µ—Ä–æ—è—Ç–Ω–æ! –£–≥–∞–¥–∞–ª —Å –ø–µ—Ä–≤–æ–≥–æ —Ä–∞–∑–∞!"),
                    2..=5 => println!("‚≠ê –û—Ç–ª–∏—á–Ω–æ! –û—á–µ–Ω—å –±—ã—Å—Ç—Ä–æ!"),
                    6..=10 => println!("üëç –•–æ—Ä–æ—à–æ! –ù–µ–ø–ª–æ—Ö–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç!"),
                    _ => println!("üòä –ì–ª–∞–≤–Ω–æ–µ, —á—Ç–æ —É–≥–∞–¥–∞–ª! –ü–æ–ø—Ä–æ–±—É–π –µ—â–µ —Ä–∞–∑!")
                }

                // –ü—Ä–µ–¥–ª–∞–≥–∞–µ–º —Å—ã–≥—Ä–∞—Ç—å –µ—â–µ —Ä–∞–∑
                println!("\nüîÑ –•–æ—á–µ—à—å —Å—ã–≥—Ä–∞—Ç—å –µ—â–µ —Ä–∞–∑? (–¥–∞/–Ω–µ—Ç)");
                let mut play_again = String::new();
                io::stdin()
                    .read_line(&mut play_again)
                    .expect("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Å—Ç—Ä–æ–∫—É");

                let play_again = play_again.trim().to_lowercase();
                if play_again == "–¥–∞" || play_again == "yes" || play_again == "y" {
                    // –ù–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—É—é –∏–≥—Ä—É
                    let secret_number = rand::thread_rng().gen_range(1..=100);
                    attempts = 0;
                    println!("\nüé≤ –û—Ç–ª–∏—á–Ω–æ! –Ø –∑–∞–≥–∞–¥–∞–ª –Ω–æ–≤–æ–µ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 100!");
                    continue;
                } else {
                    println!("üëã –°–ø–∞—Å–∏–±–æ –∑–∞ –∏–≥—Ä—É! –î–æ –≤—Å—Ç—Ä–µ—á–∏!");
                    break;
                }
            }
        }

        println!(); // –ü—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_number_generation() {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º—ã–µ —á–∏—Å–ª–∞ –≤ –Ω—É–∂–Ω–æ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ
        for _ in 0..100 {
            let num = rand::thread_rng().gen_range(1..=100);
            assert!(num >= 1 && num <= 100);
        }
    }

    #[test]
    fn test_string_parsing() {
        // –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–∞—Ä—Å–∏–Ω–≥ —Å—Ç—Ä–æ–∫ –≤ —á–∏—Å–ª–∞
        assert_eq!("42".parse::<u32>(), Ok(42));
        assert!("abc".parse::<u32>().is_err());
        assert!("0".parse::<u32>(), Ok(0));
        assert!("101".parse::<u32>(), Ok(101));
    }
}
